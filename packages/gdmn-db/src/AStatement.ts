import {Semaphore} from "gdmn-internals";
import { AMetadata } from "./AMetadata";
import {AResult} from "./AResult";
import {AResultSet, CursorType} from "./AResultSet";
import {ATransaction} from "./ATransaction";
import {IBaseExecuteOptions, TExecutor} from "./types";

export type IParams = any[] | INamedParams;

export interface INamedParams {
    [paramName: string]: any;
}

export interface IExecuteQueryOptions<R> extends IBaseExecuteOptions<AResultSet, R> {
    statement: AStatement;
    params?: IParams;
    cursorType?: CursorType;
}

/**
 * An object that represents a precompiled SQL statement.
 * A SQL statement is precompiled and stored in a Statement object.
 * This object can then be used absolute efficiently execute this statement multiple times.
 */
export abstract class AStatement {

    protected _disposed = false;

    private readonly _transaction: ATransaction;
    private readonly _sql: string;
    private readonly _lock = new Semaphore();

    protected constructor(transaction: ATransaction, sql: string) {
        this._transaction = transaction;
        this._sql = sql;
    }

    abstract get inMetadata(): AMetadata;
    abstract get outMetadata(): AMetadata;

    get transaction(): ATransaction {
        return this._transaction;
    }

    get sql(): string {
        return this._sql;
    }

    get isLock(): boolean {
        return !!this._lock.permits;
    }

    get disposed(): boolean {
        return this._disposed;
    }

    public static async executeSelf<R>(selfReceiver: TExecutor<null, AStatement>,
                                       callback: TExecutor<AStatement, R>): Promise<R> {
        let self: undefined | AStatement;
        try {
            self = await selfReceiver(null);
            return await callback(self);
        } finally {
            if (self) {
                await self.dispose();
            }
        }
    }

    public static async executeQueryResultSet<R>(
        {statement, callback, cursorType, params}: IExecuteQueryOptions<R>
    ): Promise<R> {
        return await AResultSet.executeSelf(() => statement.executeQuery(params), callback);
    }

    /**  Releases this Statement object's database and resources */
    public async dispose(): Promise<void> {
        await this._executeWithLock(async () => {
            if (this._disposed) {
                throw new Error("Statement already disposed");
            }
            await this._dispose();
            this._disposed = true;
        });
    }

    /**
     * Executes the SQL query in this Statement object and returns
     * the ResultSet object generated by the query.
     *
     * @param {IParams} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     * @param {CursorType} type
     * @returns {Promise<AResultSet>}
     * a ResultSet object that contains the data produced by the given query;
     * never null
     */
    public async executeQuery(params?: IParams, type?: CursorType): Promise<AResultSet> {
        if (this.isLock) {
            await this.waitUnlock();
        }
        if (this._disposed) {
            throw new Error("Statement already disposed");
        }
        return await this._executeQuery(params, type);
    }

    /**
     * Executes the SQL query in this Statement object and returns the result array.
     *
     * @param {IParams} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     * @returns {Promise<Result>}
     * a result object;
     * never null
     */
    public async executeReturning(params?: IParams): Promise<AResult> {
        if (this.isLock) {
            await this.waitUnlock();
        }
        if (this._disposed) {
            throw new Error("Statement already disposed");
        }
        return await this._executeReturning(params);
    }

    /**
     * Executes the SQL query in this Statement object.
     *
     * @param {IParams} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     */
    public async execute(params?: IParams): Promise<void> {
        if (this.isLock) {
            await this.waitUnlock();
        }
        if (this._disposed) {
            throw new Error("Statement already disposed");
        }
        await this._execute(params);
    }

    /**
     * Wait unlock statement. Lock occurs when disposing
     */
    public async waitUnlock(): Promise<void> {
        if (!this.isLock) {
            await this._lock.acquire();
            this._lock.release();
        }
    }

    public abstract async getPlan(): Promise<string | undefined>;

    protected async _executeWithLock<R>(callback: TExecutor<void, R>): Promise<R> {
        await this._lock.acquire();
        try {
            return await callback();
        } finally {
            this._lock.release();
        }
    }

    protected abstract async _dispose(): Promise<void>;

    protected abstract async _executeQuery(params?: IParams, type?: CursorType): Promise<AResultSet>;

    protected abstract async _executeReturning(params?: IParams): Promise<AResult>;

    protected abstract async _execute(params?: IParams): Promise<void>;
}
