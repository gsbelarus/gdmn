
Предварительная информация:

> ВНИМАНИЕ! Не все из перечисленного ниже реализовано в платформе в данный момент времени.

1. Каждая база данных имеет уникальный идентификатор (GUID), который присваивается при создании базы данных и не меняется в процессе её жизни.
2. В рамках одной базы данных учет может вестись по нескольким организациям, каждая из которых имеет свой GUID.
3. В рамках одной базы данных могут быть созданы несколько приложений (программ), каждая из которых имеет свой GUID. Приложение выбирается при входе пользователя в систему.
4. Каждый пользователь имеет свой GUID.
5. Пользователь может входить в одну или несколько *Групп пользователей*. Каждая группа имеет свой GUID.

```
                                                 ||
                                                 ||
                                                 ||
                                                 ||
+--------------+      +---------------------+    ||    +---------------------+
|              |      |                     |    ||    |                     |    
| Потребитель  |<---->| Подсистема настроек |<-------->| Back                |
|              |      |                     |    ||    |                     |
+--------------+      +---------------------+    ||    +---------------------+
                                 ^               ||              ^
                                 |               ||              |
                                 ▼               ||              ▼
                      +---------------------+    ||    +---------------------+
                      |                     |    ||    |                     |
                      | Local Storage       |    ||    |  File system        |
                      |                     |    ||    |                     |
                      +---------------------+    ||    +---------------------+
                                                 ||
                                                 ||
                                                 ||
                                                 ||
```





1. Настройки хранятся как JSON объекты. 
2. Настройки имеют тип, например, настройки грида, настройки экранной формы и т.п. Тип настройки передается строкой.
3. Тип настройки определяет внутреннюю структуру объекта. 
4. Если в процессе развития программы структура объекта с настройками определенного типа меняется, то программист может либо завести новый тип (например, 'grid.v1', 'grid.v2'), либо хранить внутри объекта номер версии структуры.
5. Для экономии места следует хранить, только отличающиеся от заданных по-умолчанию значений. 
6. Объект настроек идентифицируется следующими параметрами:
    ```typescript
    {
      // тип структуры данных. Например, 'grid' для настроек таблицы или
      // 'designer' для настроек экранной формы. Допускаются только символы,
      // разрешенные в именах файлов. 
      type: string;
      // идентификатор объекта
      objectID: string;
      // GUID учетной записи пользователя
      userID?: string;
      // Массив GUID-ов групп учетной записи пользователя
      userGroupsIDs?: string[];
      // GUID приложения. В рамках одной базы данных могут
      // быть реализованы несколько приложений, каждое из которых
      // может иметь свои специфические настройки. 
      appID?: string;
      // GUID организации. В рамках одной базы данных может вестись
      // учет по нескольким организация, каждая из которых может иметь
      // свои специфические настройки.
      organizationID?: string;
      // поддерживаем только некоторые из параметров mediaQuery, определенные 
      // стандартом CSS: orientation, minWidth, maxWidth.
      // реализуем в последнюю очередь!
      mediaQuery?: string;
    }
    ```    
7. Потребитель (программа) обращается к Подсистеме настроек передавая все или часть вышеуказанных параметров. Из них только тип структуры и идентификатор объекта являются обязательными.
8. Подсистема настроек ищет объект у которого `type` и `objectID` точно соответствуют заданным и остальные параметры наилушим образом отвечают заданным параметрам. Поиск осуществляется в следующей последовательности:
    1. Если задан пользователь, то ищем настройки для этого пользователя. 
    2. Если пользователь не задан или для него нет настроек, и задана группа (список групп), то ищем настройки для одной из групп списка. Если найдены для нескольких, то берем настройки для группы с наименьшим индексом в переданном массиве (т.е. первую по очередности).
    3. Если задана организация, то ищем сначала среди настроек для данной организации. Если не находим,
    то среди всех настроек, где организация не задана. Если задано приложение, то ищем сначала среди настроек для приложения, если нет, то среди всех настроек, у которых не задано приложение.
    4. Если настройки все еще не найдены, то ищем по типу и идентификатору объекта среди тех, у которых не задан ни пользователь, ни группа.
    5. Если задана `meiaQuery`, то среди найденных настроек выбираем ту, которая наилучшим образом отвечает заданным параметрам.
9. Вместе с данными объекта настроек записываются два параметра: *Дата и время создания или последнего изменения*, *Дата и время последнего обращения*.
10. Объекты настроек хранятся на сервере в файлах, в JSON формате:
    1. Для каждого пользователя (по которому сохранена хотя бы одна настройка) заводим отдельный файл с именем `user.GUID.json`.
    2. Для каждой группы пользователей (по которой сохранена хотя бы одна настройка) заводим отдельный файл с именем `ug.GUID.json`.
    3. Для каждого приложения (по которому сохранена хотя бы одна настройка) заводим отдельный файл с именем `app.GUID.json`.
    4. Для каждой организации (по которой сохранена хотя бы одна настройка) заводим отдельный файл с именем `org.GUID.json`.
    5. Для объектов только с типом заводим по отдельному файлу для каждого типа, с именем `type.<type>.json`.
    6. В вышеуказанные файлы записываем массив объектов с настройками.
11. Файлы выкладываются в отдельной папке рядом с файлом базы данных. Имя папки -- GUID базы данных.
12. Файлы считываются по мере обращения к соответствующим данным. Каждый файл считывается, парсится и далее хранится в виде JavaScript объекта. Для каждого такого объекта вводятся два флага: *Данные были изменены*, *Было обращение к данным*.
13. При обращении к настройкам данные берутся из этого объекта, при этом обновляется поле *Дата и время последнего обращения* и выставляется флаг *Было обращение к данным*.
14. При записи/изменении настроек изменяется объект, при этом обновляется поле *Дата и время создания или последнего изменения* и выставляется флаг *Данные были изменены*.
15. Запись объектов на диск происходит только если для них выставлен хотя бы один из флагов и по следующим событиям:
    1. Завершение работы системы.
    2. По таймеру не чаще, чем раз в 300 сек. Параметр для начала можно захардкодить константой, а затем вынести в настройки бэка.
    3. Факт чтения и записи каждого файла с настройками должен отражаться в логе системы.
16. Получив запрос на настройки подсистема на стороне клиента сначала ищет соответствующие настройки в локальном хранилище. Если найдены, то возвращает их. Далее отправляет запрос на сервер. Если сервер доступен и вернул ответ, то проверяется не подходит ли объект с сервера **лучше** чем объект из локального хранилища. Если *подходит* или, если объекты *равнозначны* и дата и время последнего изменения на сервере новее, то объект записывается в локальное хранилище (при необходимости заменяя существующий там) и вызывается переданный в функцию callback. Задача программиста решить что делать, если callback сработает: 
    1. Игнорировать
    2. Предупредить пользователя, что он может переоткрыть форму для обновления настроек
    3. Предупредить пользователя и предложить применить новые настройки
    4. Принудительно применить новые настройки
    
    Теоретически для решения данной задачи хорошо подходит *Observable*, который будет возвращать *observer-у* сначала данные из локального хранилища, затем -- полученные с сервера. При этом легко решается вопрос с пакетной обработкой, когда программа запрашивает массив настроек.
17. Для уменьшения сетевого траффика потребитель может запросить массив настроек.

## API

```ts
export interface ISettingParams {
  type: string;
  objectID: string;
  userID?: string;
  userGroupsIDs?: string[];
  appID?: string;
  organizationID?: string;
  mediaQuery?: string;
};

export interface ISettingData extends ISettingParams {
  data: any;
};

export function querySetting(params: ISettingParams): any {

};

export function saveSetting(oldData?: ISettingData, newData: ISettingsData) {

};

export function deleteSetting(data: ISettingData) {

};
```






 